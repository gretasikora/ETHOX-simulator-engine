# Agent traits pipeline: where they come from and how they reach the UI

There are **two ways** traits get into the app. Both end in the same place: **`backend/data/network.json`** → **Django API** → **frontend**.

---

## Pipeline 1: Backend-only (no simulation, no CSV)

Used when you only run the backend and never run the simulation or CSV-based init.

| Step | File | What happens |
|------|------|--------------|
| 1 | **`backend/data/generate_network.py`** | Defines `TRAIT_KEYS`: `spending`, `loyalty`, `social_influence`, `risk_tolerance`, `price_sensitivity`, `tech_adoption`, `impulsiveness`, `environmental_consciousness`. For each node, builds a `traits` dict: each key gets a value in [0, 1] (random base + cluster bias + jitter). Also sets `age`, `gender`, `cluster`, centralities. Writes **`backend/data/network.json`** (nodes + edges). |
| 2 | **`backend/data/network.json`** | On-disk graph: each node has `agent_id`, `traits` (dict of trait name → 0–1), `cluster`, `degree`, `degree_centrality`, `betweenness_centrality`, `age`, `gender`. |
| 3 | **`backend/graphapi/services.py`** | `load_graph()` reads `network.json`, normalizes each node so `node["traits"]` is a dict (default `{}`). `get_metadata(graph)` walks all nodes and collects `trait_keys` = sorted union of all trait names. |
| 4 | **`backend/graphapi/views.py`** | `GraphView.get()` returns `{ "nodes": graph["nodes"], "edges": graph["edges"], "metadata": { "trait_keys": [...], "clusters": {...}, ... } }`. |
| 5 | **Frontend** | `frontend/src/api/client.ts`: `fetchGraph()` calls `/api/graph/`. `NodeData` has `traits: Record<string, number>`. `useGraphStore` stores `nodes`, `metadata.trait_keys` → `traitKeys`. UI uses `traitKeys` for Color-by Trait, trait filter, and agent drawer. |

**Trait source in this pipeline:** Only **`backend/data/generate_network.py`** (hardcoded `TRAIT_KEYS` + random 0–1 values with cluster bias). No CSV, no simulation.

---

## Pipeline 2: Simulation + CSV (BFI-2–style traits)

Used when you run the simulation init from a **CSV** and then export the graph for the backend.

| Step | File | What happens |
|------|------|--------------|
| 1 | **CSV (e.g. `synthetic_society_20.csv` / `synthetic_society_200.csv`)** | Contains BFI-2–style columns: `Sociability`, `Assertiveness`, `Energy Level`, `Compassion`, `Respectfulness`, `Trust`, `Organization`, `Productiveness`, `Responsibility`, `Anxiety`, `Depression`, `Emotional Volatility`, `Intellectual Curiosity`, `Aesthetic Sensitivity`, `Creative Imagination`, plus `gender`, `age_group`. Each row = one agent; trait columns are typically 1–5. (This CSV can be produced by **`personalities/sampling.py`** via `generate_personality_traits()` or by exporting BFI-2 data; the repo may also ship a pre-made CSV.) |
| 2 | **`simulation/init_network.py`** | Reads the CSV (`SYNTHETIC_SOCIETY_PATH` = `synthetic_society_20.csv`). For each row, builds `traits = { col: float(row[col]) for col in FACET_COLUMNS }` (BFI-2 facet names). Creates **`Agent(i, traits, customer_behavior)`** (`agents/agent.py`: `Agent` holds `self.traits`). |
| 3 | **`simulation/network.py`** | Uses `agents` and their `traits` (e.g. `compute_extrovertedness(traits_1_to_5)`, `compute_influencibility`, similarity, sampling). Builds the adjacency matrix that defines who is connected to whom. |
| 4 | **`backend/data/generate_network_from_simulation.py`** | Calls `init_agents()` (from `simulation.init_network`) and `build_adjacency_matrix()` (from `simulation.network`). For each agent, copies `a.traits` and **normalizes 1–5 → 0–1** via `_normalize_trait_1_5_to_0_1` so the frontend trait filters/colors work. Builds nodes (with `agent_id`, `traits`, `cluster`, degree, centralities) and edges, then writes **`backend/data/network.json`**. |
| 5 | **Same as Pipeline 1 from here** | **`backend/data/network.json`** → **`backend/graphapi/services.py`** (`load_graph`, `get_metadata`) → **`backend/graphapi/views.py`** (GraphView) → **frontend** (`fetchGraph`, `useGraphStore`, trait dropdowns, filters, drawer). |

**Trait source in this pipeline:** The **CSV** (e.g. `synthetic_society_*.csv`) read by **`simulation/init_network.py`**; optionally that CSV can be generated by **`personalities/sampling.py`** (`generate_personality_traits()` + export to CSV, or similar).

---

## Optional: generating traits with `personalities/sampling.py`

| File | Role |
|------|------|
| **`personalities/sampling.py`** | Loads BFI-2 data, fits age/gender models, builds covariance from R. **`generate_personality_traits(n, seed, p_gender, p_age)`** returns a list of dicts `{ facet_name: score }` (scores in 1–5). Can be used to **generate** the agent trait rows that you then put into a CSV or pass into the simulation. It does **not** by itself write `network.json` or the CSV; it’s a helper to produce trait vectors. |

So: **personalities/sampling.py** is a possible **upstream** source of the numbers that end up in the CSV (or in memory for the simulation); it is not part of the backend graph API.

---

## Single diagram (both pipelines)

```
Pipeline 1 (backend-only):
  backend/data/generate_network.py  →  backend/data/network.json
                                              ↓
  backend/graphapi/services.py  (load_graph, get_metadata)
                                              ↓
  backend/graphapi/views.py  (GraphView: nodes + edges + metadata.trait_keys)
                                              ↓
  Frontend: fetchGraph() → useGraphStore (nodes, traitKeys) → UI

Pipeline 2 (simulation + CSV):
  CSV (synthetic_society_*.csv) or personalities/sampling.py → CSV
              ↓
  simulation/init_network.py  (read CSV → Agent(id, traits, …))
              ↓
  simulation/network.py  (build_adjacency_matrix(agents))
              ↓
  backend/data/generate_network_from_simulation.py  (agents + adjacency → network.json, traits 1–5 → 0–1)
              ↓
  backend/data/network.json  →  (same as Pipeline 1 from here)
  backend/graphapi/services.py  →  backend/graphapi/views.py  →  Frontend
```

---

## Summary

- **Traits are always read by the frontend from the same place:** the **`nodes`** array returned by **`GET /api/graph/`**, with **`metadata.trait_keys`** listing which trait names exist.
- **Where those traits are created** depends on how you run the project:
  - **Only backend:** **`backend/data/generate_network.py`** (fixed list of trait names, random 0–1).
  - **Simulation + CSV:** **CSV** (e.g. `synthetic_society_20.csv`) with BFI-2 columns → **`simulation/init_network.py`** → **`backend/data/generate_network_from_simulation.py`** (writes `network.json` with traits normalized to 0–1).
- **Optional upstream:** **`personalities/sampling.py`** can generate BFI-2–style trait vectors that you then put into the CSV or feed into the simulation.

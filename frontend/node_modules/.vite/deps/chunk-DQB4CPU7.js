import {
  __commonJS
} from "./chunk-G3PMV62Z.js";

// node_modules/sigma/rendering/webgl/shaders/utils.js
var require_utils = __commonJS({
  "node_modules/sigma/rendering/webgl/shaders/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadProgram = exports.loadFragmentShader = exports.loadVertexShader = void 0;
    function loadShader(type, gl, source) {
      var glType = type === "VERTEX" ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER;
      var shader = gl.createShader(glType);
      if (shader === null) {
        throw new Error("loadShader: error while creating the shader");
      }
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      var successfullyCompiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
      if (!successfullyCompiled) {
        var infoLog = gl.getShaderInfoLog(shader);
        gl.deleteShader(shader);
        throw new Error("loadShader: error while compiling the shader:\n".concat(infoLog, "\n").concat(source));
      }
      return shader;
    }
    function loadVertexShader(gl, source) {
      return loadShader("VERTEX", gl, source);
    }
    exports.loadVertexShader = loadVertexShader;
    function loadFragmentShader(gl, source) {
      return loadShader("FRAGMENT", gl, source);
    }
    exports.loadFragmentShader = loadFragmentShader;
    function loadProgram(gl, shaders) {
      var program = gl.createProgram();
      if (program === null) {
        throw new Error("loadProgram: error while creating the program.");
      }
      var i, l;
      for (i = 0, l = shaders.length; i < l; i++)
        gl.attachShader(program, shaders[i]);
      gl.linkProgram(program);
      var successfullyLinked = gl.getProgramParameter(program, gl.LINK_STATUS);
      if (!successfullyLinked) {
        gl.deleteProgram(program);
        throw new Error("loadProgram: error while linking the program.");
      }
      return program;
    }
    exports.loadProgram = loadProgram;
  }
});

// node_modules/sigma/rendering/webgl/programs/common/program.js
var require_program = __commonJS({
  "node_modules/sigma/rendering/webgl/programs/common/program.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbstractProgram = void 0;
    var utils_1 = require_utils();
    var AbstractProgram = (
      /** @class */
      function() {
        function AbstractProgram2(gl, vertexShaderSource, fragmentShaderSource, points, attributes) {
          this.array = new Float32Array();
          this.points = points;
          this.attributes = attributes;
          this.gl = gl;
          this.vertexShaderSource = vertexShaderSource;
          this.fragmentShaderSource = fragmentShaderSource;
          var buffer = gl.createBuffer();
          if (buffer === null)
            throw new Error("AbstractProgram: error while creating the buffer");
          this.buffer = buffer;
          gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
          this.vertexShader = (0, utils_1.loadVertexShader)(gl, this.vertexShaderSource);
          this.fragmentShader = (0, utils_1.loadFragmentShader)(gl, this.fragmentShaderSource);
          this.program = (0, utils_1.loadProgram)(gl, [this.vertexShader, this.fragmentShader]);
        }
        AbstractProgram2.prototype.bufferData = function() {
          var gl = this.gl;
          gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.DYNAMIC_DRAW);
        };
        AbstractProgram2.prototype.allocate = function(capacity) {
          this.array = new Float32Array(this.points * this.attributes * capacity);
        };
        AbstractProgram2.prototype.hasNothingToRender = function() {
          return this.array.length === 0;
        };
        return AbstractProgram2;
      }()
    );
    exports.AbstractProgram = AbstractProgram;
  }
});

// node_modules/sigma/rendering/webgl/programs/common/node.js
var require_node = __commonJS({
  "node_modules/sigma/rendering/webgl/programs/common/node.js"(exports) {
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createNodeCompoundProgram = exports.AbstractNodeProgram = void 0;
    var program_1 = require_program();
    var AbstractNodeProgram = (
      /** @class */
      function(_super) {
        __extends(AbstractNodeProgram2, _super);
        function AbstractNodeProgram2(gl, vertexShaderSource, fragmentShaderSource, points, attributes) {
          var _this = _super.call(this, gl, vertexShaderSource, fragmentShaderSource, points, attributes) || this;
          _this.positionLocation = gl.getAttribLocation(_this.program, "a_position");
          _this.sizeLocation = gl.getAttribLocation(_this.program, "a_size");
          _this.colorLocation = gl.getAttribLocation(_this.program, "a_color");
          var matrixLocation = gl.getUniformLocation(_this.program, "u_matrix");
          if (matrixLocation === null)
            throw new Error("AbstractNodeProgram: error while getting matrixLocation");
          _this.matrixLocation = matrixLocation;
          var ratioLocation = gl.getUniformLocation(_this.program, "u_ratio");
          if (ratioLocation === null)
            throw new Error("AbstractNodeProgram: error while getting ratioLocation");
          _this.ratioLocation = ratioLocation;
          var scaleLocation = gl.getUniformLocation(_this.program, "u_scale");
          if (scaleLocation === null)
            throw new Error("AbstractNodeProgram: error while getting scaleLocation");
          _this.scaleLocation = scaleLocation;
          return _this;
        }
        AbstractNodeProgram2.prototype.bind = function() {
          var gl = this.gl;
          gl.enableVertexAttribArray(this.positionLocation);
          gl.enableVertexAttribArray(this.sizeLocation);
          gl.enableVertexAttribArray(this.colorLocation);
          gl.vertexAttribPointer(this.positionLocation, 2, gl.FLOAT, false, this.attributes * Float32Array.BYTES_PER_ELEMENT, 0);
          gl.vertexAttribPointer(this.sizeLocation, 1, gl.FLOAT, false, this.attributes * Float32Array.BYTES_PER_ELEMENT, 8);
          gl.vertexAttribPointer(this.colorLocation, 4, gl.UNSIGNED_BYTE, true, this.attributes * Float32Array.BYTES_PER_ELEMENT, 12);
        };
        return AbstractNodeProgram2;
      }(program_1.AbstractProgram)
    );
    exports.AbstractNodeProgram = AbstractNodeProgram;
    function createNodeCompoundProgram(programClasses) {
      return (
        /** @class */
        function() {
          function NodeCompoundProgram(gl, renderer) {
            this.programs = programClasses.map(function(ProgramClass) {
              return new ProgramClass(gl, renderer);
            });
          }
          NodeCompoundProgram.prototype.bufferData = function() {
            this.programs.forEach(function(program) {
              return program.bufferData();
            });
          };
          NodeCompoundProgram.prototype.allocate = function(capacity) {
            this.programs.forEach(function(program) {
              return program.allocate(capacity);
            });
          };
          NodeCompoundProgram.prototype.bind = function() {
          };
          NodeCompoundProgram.prototype.render = function(params) {
            this.programs.forEach(function(program) {
              program.bind();
              program.bufferData();
              program.render(params);
            });
          };
          NodeCompoundProgram.prototype.process = function(data, hidden, offset) {
            this.programs.forEach(function(program) {
              return program.process(data, hidden, offset);
            });
          };
          return NodeCompoundProgram;
        }()
      );
    }
    exports.createNodeCompoundProgram = createNodeCompoundProgram;
  }
});

export {
  require_program,
  require_node
};
//# sourceMappingURL=chunk-DQB4CPU7.js.map

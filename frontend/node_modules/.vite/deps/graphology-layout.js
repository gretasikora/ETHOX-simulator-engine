import {
  require_is_graph
} from "./chunk-ULR5OFWV.js";
import {
  __commonJS
} from "./chunk-5WRI5ZAA.js";

// node_modules/graphology-utils/defaults.js
var require_defaults = __commonJS({
  "node_modules/graphology-utils/defaults.js"(exports, module) {
    function isLeaf(o) {
      return !o || typeof o !== "object" || typeof o === "function" || Array.isArray(o) || o instanceof Set || o instanceof Map || o instanceof RegExp || o instanceof Date;
    }
    function resolveDefaults(target, defaults) {
      target = target || {};
      var output = {};
      for (var k in defaults) {
        var existing = target[k];
        var def = defaults[k];
        if (!isLeaf(def)) {
          output[k] = resolveDefaults(existing, def);
          continue;
        }
        if (existing === void 0) {
          output[k] = def;
        } else {
          output[k] = existing;
        }
      }
      return output;
    }
    module.exports = resolveDefaults;
  }
});

// node_modules/pandemonium/random.js
var require_random = __commonJS({
  "node_modules/pandemonium/random.js"(exports, module) {
    function createRandom(rng) {
      return function(a, b) {
        return a + Math.floor(rng() * (b - a + 1));
      };
    }
    var random = createRandom(Math.random);
    random.createRandom = createRandom;
    module.exports = random;
  }
});

// node_modules/pandemonium/shuffle-in-place.js
var require_shuffle_in_place = __commonJS({
  "node_modules/pandemonium/shuffle-in-place.js"(exports, module) {
    var createRandom = require_random().createRandom;
    function createShuffleInPlace(rng) {
      var customRandom = createRandom(rng);
      return function(sequence) {
        var length = sequence.length, lastIndex = length - 1;
        var index = -1;
        while (++index < length) {
          var r = customRandom(index, lastIndex), value = sequence[r];
          sequence[r] = sequence[index];
          sequence[index] = value;
        }
      };
    }
    var shuffleInPlace = createShuffleInPlace(Math.random);
    shuffleInPlace.createShuffleInPlace = createShuffleInPlace;
    module.exports = shuffleInPlace;
  }
});

// node_modules/graphology-layout/circlepack.js
var require_circlepack = __commonJS({
  "node_modules/graphology-layout/circlepack.js"(exports, module) {
    var resolveDefaults = require_defaults();
    var isGraph = require_is_graph();
    var shuffle = require_shuffle_in_place();
    var DEFAULTS = {
      attributes: {
        x: "x",
        y: "y"
      },
      center: 0,
      hierarchyAttributes: [],
      rng: Math.random,
      scale: 1
    };
    function CircleWrap(id, x, y, r, circleWrap) {
      this.wrappedCircle = circleWrap || null;
      this.children = {};
      this.countChildren = 0;
      this.id = id || null;
      this.next = null;
      this.previous = null;
      this.x = x || null;
      this.y = y || null;
      if (circleWrap) this.r = 1010101;
      else this.r = r || 999;
    }
    CircleWrap.prototype.hasChildren = function() {
      return this.countChildren > 0;
    };
    CircleWrap.prototype.addChild = function(id, child) {
      this.children[id] = child;
      ++this.countChildren;
    };
    CircleWrap.prototype.getChild = function(id) {
      if (!this.children.hasOwnProperty(id)) {
        var circleWrap = new CircleWrap();
        this.children[id] = circleWrap;
        ++this.countChildren;
      }
      return this.children[id];
    };
    CircleWrap.prototype.applyPositionToChildren = function() {
      if (this.hasChildren()) {
        var root = this;
        for (var key in root.children) {
          var child = root.children[key];
          child.x += root.x;
          child.y += root.y;
          child.applyPositionToChildren();
        }
      }
    };
    function setNode(graph, parentCircle, posMap) {
      for (var key in parentCircle.children) {
        var circle = parentCircle.children[key];
        if (circle.hasChildren()) {
          setNode(graph, circle, posMap);
        } else {
          posMap[circle.id] = { x: circle.x, y: circle.y };
        }
      }
    }
    function enclosesNot(a, b) {
      var dr = a.r - b.r;
      var dx = b.x - a.x;
      var dy = b.y - a.y;
      return dr < 0 || dr * dr < dx * dx + dy * dy;
    }
    function enclosesWeak(a, b) {
      var dr = a.r - b.r + 1e-6;
      var dx = b.x - a.x;
      var dy = b.y - a.y;
      return dr > 0 && dr * dr > dx * dx + dy * dy;
    }
    function enclosesWeakAll(a, B) {
      for (var i = 0; i < B.length; ++i) {
        if (!enclosesWeak(a, B[i])) {
          return false;
        }
      }
      return true;
    }
    function encloseBasis1(a) {
      return new CircleWrap(null, a.x, a.y, a.r);
    }
    function encloseBasis2(a, b) {
      var x1 = a.x, y1 = a.y, r1 = a.r, x2 = b.x, y2 = b.y, r2 = b.r, x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1, l = Math.sqrt(x21 * x21 + y21 * y21);
      return new CircleWrap(
        null,
        (x1 + x2 + x21 / l * r21) / 2,
        (y1 + y2 + y21 / l * r21) / 2,
        (l + r1 + r2) / 2
      );
    }
    function encloseBasis3(a, b, c) {
      var x1 = a.x, y1 = a.y, r1 = a.r, x2 = b.x, y2 = b.y, r2 = b.r, x3 = c.x, y3 = c.y, r3 = c.r, a2 = x1 - x2, a3 = x1 - x3, b2 = y1 - y2, b3 = y1 - y3, c2 = r2 - r1, c3 = r3 - r1, d1 = x1 * x1 + y1 * y1 - r1 * r1, d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2, d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3, ab = a3 * b2 - a2 * b3, xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1, xb = (b3 * c2 - b2 * c3) / ab, ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1, yb = (a2 * c3 - a3 * c2) / ab, A = xb * xb + yb * yb - 1, B = 2 * (r1 + xa * xb + ya * yb), C = xa * xa + ya * ya - r1 * r1, r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
      return new CircleWrap(null, x1 + xa + xb * r, y1 + ya + yb * r, r);
    }
    function encloseBasis(B) {
      switch (B.length) {
        case 1:
          return encloseBasis1(B[0]);
        case 2:
          return encloseBasis2(B[0], B[1]);
        case 3:
          return encloseBasis3(B[0], B[1], B[2]);
        default:
          throw new Error(
            "graphology-layout/circlepack: Invalid basis length " + B.length
          );
      }
    }
    function extendBasis(B, p) {
      var i, j;
      if (enclosesWeakAll(p, B)) return [p];
      for (i = 0; i < B.length; ++i) {
        if (enclosesNot(p, B[i]) && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
          return [B[i], p];
        }
      }
      for (i = 0; i < B.length - 1; ++i) {
        for (j = i + 1; j < B.length; ++j) {
          if (enclosesNot(encloseBasis2(B[i], B[j]), p) && enclosesNot(encloseBasis2(B[i], p), B[j]) && enclosesNot(encloseBasis2(B[j], p), B[i]) && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
            return [B[i], B[j], p];
          }
        }
      }
      throw new Error("graphology-layout/circlepack: extendBasis failure !");
    }
    function score(node) {
      var a = node.wrappedCircle;
      var b = node.next.wrappedCircle;
      var ab = a.r + b.r;
      var dx = (a.x * b.r + b.x * a.r) / ab;
      var dy = (a.y * b.r + b.y * a.r) / ab;
      return dx * dx + dy * dy;
    }
    function enclose(circles, shuffleFunc) {
      var i = 0;
      var circlesLoc = circles.slice();
      var n = circles.length;
      var B = [];
      var p;
      var e;
      shuffleFunc(circlesLoc);
      while (i < n) {
        p = circlesLoc[i];
        if (e && enclosesWeak(e, p)) {
          ++i;
        } else {
          B = extendBasis(B, p);
          e = encloseBasis(B);
          i = 0;
        }
      }
      return e;
    }
    function place(b, a, c) {
      var dx = b.x - a.x, x, a2, dy = b.y - a.y, y, b2, d2 = dx * dx + dy * dy;
      if (d2) {
        a2 = a.r + c.r;
        a2 *= a2;
        b2 = b.r + c.r;
        b2 *= b2;
        if (a2 > b2) {
          x = (d2 + b2 - a2) / (2 * d2);
          y = Math.sqrt(Math.max(0, b2 / d2 - x * x));
          c.x = b.x - x * dx - y * dy;
          c.y = b.y - x * dy + y * dx;
        } else {
          x = (d2 + a2 - b2) / (2 * d2);
          y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
          c.x = a.x + x * dx - y * dy;
          c.y = a.y + x * dy + y * dx;
        }
      } else {
        c.x = a.x + c.r;
        c.y = a.y;
      }
    }
    function intersects(a, b) {
      var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;
      return dr > 0 && dr * dr > dx * dx + dy * dy;
    }
    function packEnclose(circles, shuffleFunc) {
      var n = circles.length;
      if (n === 0) return 0;
      var a, b, c, aa, ca, i, j, k, sj, sk;
      a = circles[0];
      a.x = 0;
      a.y = 0;
      if (n <= 1) return a.r;
      b = circles[1];
      a.x = -b.r;
      b.x = a.r;
      b.y = 0;
      if (n <= 2) return a.r + b.r;
      c = circles[2];
      place(b, a, c);
      a = new CircleWrap(null, null, null, null, a);
      b = new CircleWrap(null, null, null, null, b);
      c = new CircleWrap(null, null, null, null, c);
      a.next = c.previous = b;
      b.next = a.previous = c;
      c.next = b.previous = a;
      pack: for (i = 3; i < n; ++i) {
        c = circles[i];
        place(a.wrappedCircle, b.wrappedCircle, c);
        c = new CircleWrap(null, null, null, null, c);
        j = b.next;
        k = a.previous;
        sj = b.wrappedCircle.r;
        sk = a.wrappedCircle.r;
        do {
          if (sj <= sk) {
            if (intersects(j.wrappedCircle, c.wrappedCircle)) {
              b = j;
              a.next = b;
              b.previous = a;
              --i;
              continue pack;
            }
            sj += j.wrappedCircle.r;
            j = j.next;
          } else {
            if (intersects(k.wrappedCircle, c.wrappedCircle)) {
              a = k;
              a.next = b;
              b.previous = a;
              --i;
              continue pack;
            }
            sk += k.wrappedCircle.r;
            k = k.previous;
          }
        } while (j !== k.next);
        c.previous = a;
        c.next = b;
        a.next = b.previous = b = c;
        aa = score(a);
        while ((c = c.next) !== b) {
          if ((ca = score(c)) < aa) {
            a = c;
            aa = ca;
          }
        }
        b = a.next;
      }
      a = [b.wrappedCircle];
      c = b;
      var safety = 1e4;
      while ((c = c.next) !== b) {
        if (--safety === 0) {
          break;
        }
        a.push(c.wrappedCircle);
      }
      c = enclose(a, shuffleFunc);
      for (i = 0; i < n; ++i) {
        a = circles[i];
        a.x -= c.x;
        a.y -= c.y;
      }
      return c.r;
    }
    function packHierarchy(parentCircle, shuffleFunc) {
      var r = 0;
      if (parentCircle.hasChildren()) {
        for (var key in parentCircle.children) {
          var circle = parentCircle.children[key];
          if (circle.hasChildren()) {
            circle.r = packHierarchy(circle, shuffleFunc);
          }
        }
        r = packEnclose(Object.values(parentCircle.children), shuffleFunc);
      }
      return r;
    }
    function packHierarchyAndShift(parentCircle, shuffleFunc) {
      packHierarchy(parentCircle, shuffleFunc);
      for (var key in parentCircle.children) {
        var circle = parentCircle.children[key];
        circle.applyPositionToChildren();
      }
    }
    function genericCirclePackLayout(assign, graph, options) {
      if (!isGraph(graph))
        throw new Error(
          "graphology-layout/circlepack: the given graph is not a valid graphology instance."
        );
      options = resolveDefaults(options, DEFAULTS);
      var posMap = {}, positions = {}, nodes = graph.nodes(), center = options.center, hierarchyAttributes = options.hierarchyAttributes, shuffleFunc = shuffle.createShuffleInPlace(options.rng), scale = options.scale;
      var container = new CircleWrap();
      graph.forEachNode(function(key, attributes) {
        var r = attributes.size ? attributes.size : 1;
        var newCircleWrap = new CircleWrap(key, null, null, r);
        var parentContainer = container;
        hierarchyAttributes.forEach(function(v) {
          var attr = attributes[v];
          parentContainer = parentContainer.getChild(attr);
        });
        parentContainer.addChild(key, newCircleWrap);
      });
      packHierarchyAndShift(container, shuffleFunc);
      setNode(graph, container, posMap);
      var l = nodes.length, x, y, i;
      for (i = 0; i < l; i++) {
        var node = nodes[i];
        x = center + scale * posMap[node].x;
        y = center + scale * posMap[node].y;
        positions[node] = {
          x,
          y
        };
        if (assign) {
          graph.setNodeAttribute(node, options.attributes.x, x);
          graph.setNodeAttribute(node, options.attributes.y, y);
        }
      }
      return positions;
    }
    var circlePackLayout = genericCirclePackLayout.bind(null, false);
    circlePackLayout.assign = genericCirclePackLayout.bind(null, true);
    module.exports = circlePackLayout;
  }
});

// node_modules/graphology-layout/circular.js
var require_circular = __commonJS({
  "node_modules/graphology-layout/circular.js"(exports, module) {
    var resolveDefaults = require_defaults();
    var isGraph = require_is_graph();
    var DEFAULTS = {
      dimensions: ["x", "y"],
      center: 0.5,
      scale: 1
    };
    function genericCircularLayout(assign, graph, options) {
      if (!isGraph(graph))
        throw new Error(
          "graphology-layout/random: the given graph is not a valid graphology instance."
        );
      options = resolveDefaults(options, DEFAULTS);
      var dimensions = options.dimensions;
      if (!Array.isArray(dimensions) || dimensions.length !== 2)
        throw new Error("graphology-layout/random: given dimensions are invalid.");
      var center = options.center;
      var scale = options.scale;
      var tau = Math.PI * 2;
      var offset = (center - 0.5) * scale;
      var l = graph.order;
      var x = dimensions[0];
      var y = dimensions[1];
      function assignPosition(i2, target) {
        target[x] = scale * Math.cos(i2 * tau / l) + offset;
        target[y] = scale * Math.sin(i2 * tau / l) + offset;
        return target;
      }
      var i = 0;
      if (!assign) {
        var positions = {};
        graph.forEachNode(function(node) {
          positions[node] = assignPosition(i++, {});
        });
        return positions;
      }
      graph.updateEachNodeAttributes(
        function(_, attr) {
          assignPosition(i++, attr);
          return attr;
        },
        {
          attributes: dimensions
        }
      );
    }
    var circularLayout = genericCircularLayout.bind(null, false);
    circularLayout.assign = genericCircularLayout.bind(null, true);
    module.exports = circularLayout;
  }
});

// node_modules/graphology-layout/random.js
var require_random2 = __commonJS({
  "node_modules/graphology-layout/random.js"(exports, module) {
    var resolveDefaults = require_defaults();
    var isGraph = require_is_graph();
    var DEFAULTS = {
      dimensions: ["x", "y"],
      center: 0.5,
      rng: Math.random,
      scale: 1
    };
    function genericRandomLayout(assign, graph, options) {
      if (!isGraph(graph))
        throw new Error(
          "graphology-layout/random: the given graph is not a valid graphology instance."
        );
      options = resolveDefaults(options, DEFAULTS);
      var dimensions = options.dimensions;
      if (!Array.isArray(dimensions) || dimensions.length < 1)
        throw new Error("graphology-layout/random: given dimensions are invalid.");
      var d = dimensions.length;
      var center = options.center;
      var rng = options.rng;
      var scale = options.scale;
      var offset = (center - 0.5) * scale;
      function assignPosition(target) {
        for (var i = 0; i < d; i++) {
          target[dimensions[i]] = rng() * scale + offset;
        }
        return target;
      }
      if (!assign) {
        var positions = {};
        graph.forEachNode(function(node) {
          positions[node] = assignPosition({});
        });
        return positions;
      }
      graph.updateEachNodeAttributes(
        function(_, attr) {
          assignPosition(attr);
          return attr;
        },
        {
          attributes: dimensions
        }
      );
    }
    var randomLayout = genericRandomLayout.bind(null, false);
    randomLayout.assign = genericRandomLayout.bind(null, true);
    module.exports = randomLayout;
  }
});

// node_modules/graphology-layout/rotation.js
var require_rotation = __commonJS({
  "node_modules/graphology-layout/rotation.js"(exports, module) {
    var resolveDefaults = require_defaults();
    var isGraph = require_is_graph();
    var RAD_CONVERSION = Math.PI / 180;
    var DEFAULTS = {
      dimensions: ["x", "y"],
      centeredOnZero: false,
      degrees: false
    };
    function genericRotation(assign, graph, angle, options) {
      if (!isGraph(graph))
        throw new Error(
          "graphology-layout/rotation: the given graph is not a valid graphology instance."
        );
      options = resolveDefaults(options, DEFAULTS);
      if (options.degrees) angle *= RAD_CONVERSION;
      var dimensions = options.dimensions;
      if (!Array.isArray(dimensions) || dimensions.length !== 2)
        throw new Error("graphology-layout/random: given dimensions are invalid.");
      if (graph.order === 0) {
        if (assign) return;
        return {};
      }
      var xd = dimensions[0];
      var yd = dimensions[1];
      var xCenter = 0;
      var yCenter = 0;
      if (!options.centeredOnZero) {
        var xMin = Infinity;
        var xMax = -Infinity;
        var yMin = Infinity;
        var yMax = -Infinity;
        graph.forEachNode(function(node, attr) {
          var x = attr[xd];
          var y = attr[yd];
          if (x < xMin) xMin = x;
          if (x > xMax) xMax = x;
          if (y < yMin) yMin = y;
          if (y > yMax) yMax = y;
        });
        xCenter = (xMin + xMax) / 2;
        yCenter = (yMin + yMax) / 2;
      }
      var cos = Math.cos(angle);
      var sin = Math.sin(angle);
      function assignPosition(target) {
        var x = target[xd];
        var y = target[yd];
        target[xd] = xCenter + (x - xCenter) * cos - (y - yCenter) * sin;
        target[yd] = yCenter + (x - xCenter) * sin + (y - yCenter) * cos;
        return target;
      }
      if (!assign) {
        var positions = {};
        graph.forEachNode(function(node, attr) {
          var o = {};
          o[xd] = attr[xd];
          o[yd] = attr[yd];
          positions[node] = assignPosition(o);
        });
        return positions;
      }
      graph.updateEachNodeAttributes(
        function(_, attr) {
          assignPosition(attr);
          return attr;
        },
        {
          attributes: dimensions
        }
      );
    }
    var rotation = genericRotation.bind(null, false);
    rotation.assign = genericRotation.bind(null, true);
    module.exports = rotation;
  }
});

// node_modules/graphology-layout/index.js
var require_graphology_layout = __commonJS({
  "node_modules/graphology-layout/index.js"(exports) {
    exports.circlepack = require_circlepack();
    exports.circular = require_circular();
    exports.random = require_random2();
    exports.rotation = require_rotation();
  }
});
export default require_graphology_layout();
//# sourceMappingURL=graphology-layout.js.map

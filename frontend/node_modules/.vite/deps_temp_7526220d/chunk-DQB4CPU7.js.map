{
  "version": 3,
  "sources": ["../../sigma/rendering/webgl/shaders/utils.js", "../../sigma/rendering/webgl/programs/common/program.js", "../../sigma/rendering/webgl/programs/common/node.js"],
  "sourcesContent": ["\"use strict\";\n/**\n * Sigma.js Shader Utils\n * ======================\n *\n * Code used to load sigma's shaders.\n * @module\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.loadProgram = exports.loadFragmentShader = exports.loadVertexShader = void 0;\n/**\n * Function used to load a shader.\n */\nfunction loadShader(type, gl, source) {\n    var glType = type === \"VERTEX\" ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER;\n    // Creating the shader\n    var shader = gl.createShader(glType);\n    if (shader === null) {\n        throw new Error(\"loadShader: error while creating the shader\");\n    }\n    // Loading source\n    gl.shaderSource(shader, source);\n    // Compiling the shader\n    gl.compileShader(shader);\n    // Retrieving compilation status\n    var successfullyCompiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n    // Throwing if something went awry\n    if (!successfullyCompiled) {\n        var infoLog = gl.getShaderInfoLog(shader);\n        gl.deleteShader(shader);\n        throw new Error(\"loadShader: error while compiling the shader:\\n\".concat(infoLog, \"\\n\").concat(source));\n    }\n    return shader;\n}\nfunction loadVertexShader(gl, source) {\n    return loadShader(\"VERTEX\", gl, source);\n}\nexports.loadVertexShader = loadVertexShader;\nfunction loadFragmentShader(gl, source) {\n    return loadShader(\"FRAGMENT\", gl, source);\n}\nexports.loadFragmentShader = loadFragmentShader;\n/**\n * Function used to load a program.\n */\nfunction loadProgram(gl, shaders) {\n    var program = gl.createProgram();\n    if (program === null) {\n        throw new Error(\"loadProgram: error while creating the program.\");\n    }\n    var i, l;\n    // Attaching the shaders\n    for (i = 0, l = shaders.length; i < l; i++)\n        gl.attachShader(program, shaders[i]);\n    gl.linkProgram(program);\n    // Checking status\n    var successfullyLinked = gl.getProgramParameter(program, gl.LINK_STATUS);\n    if (!successfullyLinked) {\n        gl.deleteProgram(program);\n        throw new Error(\"loadProgram: error while linking the program.\");\n    }\n    return program;\n}\nexports.loadProgram = loadProgram;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AbstractProgram = void 0;\n/**\n * Sigma.js WebGL Renderer Program\n * ================================\n *\n * Class representing a single WebGL program used by sigma's WebGL renderer.\n * @module\n */\nvar utils_1 = require(\"../../shaders/utils\");\n/**\n * Abstract Program class.\n *\n * @constructor\n */\nvar AbstractProgram = /** @class */ (function () {\n    function AbstractProgram(gl, vertexShaderSource, fragmentShaderSource, points, attributes) {\n        this.array = new Float32Array();\n        this.points = points;\n        this.attributes = attributes;\n        this.gl = gl;\n        this.vertexShaderSource = vertexShaderSource;\n        this.fragmentShaderSource = fragmentShaderSource;\n        var buffer = gl.createBuffer();\n        if (buffer === null)\n            throw new Error(\"AbstractProgram: error while creating the buffer\");\n        this.buffer = buffer;\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);\n        this.vertexShader = (0, utils_1.loadVertexShader)(gl, this.vertexShaderSource);\n        this.fragmentShader = (0, utils_1.loadFragmentShader)(gl, this.fragmentShaderSource);\n        this.program = (0, utils_1.loadProgram)(gl, [this.vertexShader, this.fragmentShader]);\n    }\n    AbstractProgram.prototype.bufferData = function () {\n        var gl = this.gl;\n        gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.DYNAMIC_DRAW);\n    };\n    AbstractProgram.prototype.allocate = function (capacity) {\n        this.array = new Float32Array(this.points * this.attributes * capacity);\n    };\n    AbstractProgram.prototype.hasNothingToRender = function () {\n        return this.array.length === 0;\n    };\n    return AbstractProgram;\n}());\nexports.AbstractProgram = AbstractProgram;\n", "\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createNodeCompoundProgram = exports.AbstractNodeProgram = void 0;\n/**\n * Sigma.js WebGL Abstract Node Program\n * =====================================\n *\n * @module\n */\nvar program_1 = require(\"./program\");\n/**\n * Node Program class.\n *\n * @constructor\n */\nvar AbstractNodeProgram = /** @class */ (function (_super) {\n    __extends(AbstractNodeProgram, _super);\n    function AbstractNodeProgram(gl, vertexShaderSource, fragmentShaderSource, points, attributes) {\n        var _this = _super.call(this, gl, vertexShaderSource, fragmentShaderSource, points, attributes) || this;\n        // Locations\n        _this.positionLocation = gl.getAttribLocation(_this.program, \"a_position\");\n        _this.sizeLocation = gl.getAttribLocation(_this.program, \"a_size\");\n        _this.colorLocation = gl.getAttribLocation(_this.program, \"a_color\");\n        // Uniform Location\n        var matrixLocation = gl.getUniformLocation(_this.program, \"u_matrix\");\n        if (matrixLocation === null)\n            throw new Error(\"AbstractNodeProgram: error while getting matrixLocation\");\n        _this.matrixLocation = matrixLocation;\n        var ratioLocation = gl.getUniformLocation(_this.program, \"u_ratio\");\n        if (ratioLocation === null)\n            throw new Error(\"AbstractNodeProgram: error while getting ratioLocation\");\n        _this.ratioLocation = ratioLocation;\n        var scaleLocation = gl.getUniformLocation(_this.program, \"u_scale\");\n        if (scaleLocation === null)\n            throw new Error(\"AbstractNodeProgram: error while getting scaleLocation\");\n        _this.scaleLocation = scaleLocation;\n        return _this;\n    }\n    AbstractNodeProgram.prototype.bind = function () {\n        var gl = this.gl;\n        gl.enableVertexAttribArray(this.positionLocation);\n        gl.enableVertexAttribArray(this.sizeLocation);\n        gl.enableVertexAttribArray(this.colorLocation);\n        gl.vertexAttribPointer(this.positionLocation, 2, gl.FLOAT, false, this.attributes * Float32Array.BYTES_PER_ELEMENT, 0);\n        gl.vertexAttribPointer(this.sizeLocation, 1, gl.FLOAT, false, this.attributes * Float32Array.BYTES_PER_ELEMENT, 8);\n        gl.vertexAttribPointer(this.colorLocation, 4, gl.UNSIGNED_BYTE, true, this.attributes * Float32Array.BYTES_PER_ELEMENT, 12);\n    };\n    return AbstractNodeProgram;\n}(program_1.AbstractProgram));\nexports.AbstractNodeProgram = AbstractNodeProgram;\n/**\n * Helper function combining two or more programs into a single compound one.\n * Note that this is more a quick & easy way to combine program than a really\n * performant option. More performant programs can be written entirely.\n *\n * @param  {array}    programClasses - Program classes to combine.\n * @return {function}\n */\nfunction createNodeCompoundProgram(programClasses) {\n    return /** @class */ (function () {\n        function NodeCompoundProgram(gl, renderer) {\n            this.programs = programClasses.map(function (ProgramClass) { return new ProgramClass(gl, renderer); });\n        }\n        NodeCompoundProgram.prototype.bufferData = function () {\n            this.programs.forEach(function (program) { return program.bufferData(); });\n        };\n        NodeCompoundProgram.prototype.allocate = function (capacity) {\n            this.programs.forEach(function (program) { return program.allocate(capacity); });\n        };\n        NodeCompoundProgram.prototype.bind = function () {\n            // nothing todo, it's already done in each program constructor\n        };\n        NodeCompoundProgram.prototype.render = function (params) {\n            this.programs.forEach(function (program) {\n                program.bind();\n                program.bufferData();\n                program.render(params);\n            });\n        };\n        NodeCompoundProgram.prototype.process = function (data, hidden, offset) {\n            this.programs.forEach(function (program) { return program.process(data, hidden, offset); });\n        };\n        return NodeCompoundProgram;\n    }());\n}\nexports.createNodeCompoundProgram = createNodeCompoundProgram;\n"],
  "mappings": "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",
  "names": ["AbstractProgram", "d", "b", "AbstractNodeProgram"]
}

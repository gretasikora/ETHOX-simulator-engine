{
  "version": 3,
  "sources": ["../../graphology-layout-forceatlas2/iterate.js", "../../graphology-layout-forceatlas2/helpers.js", "../../graphology-layout-forceatlas2/defaults.js", "../../graphology-layout-forceatlas2/index.js"],
  "sourcesContent": ["/* eslint no-constant-condition: 0 */\n/**\n * Graphology ForceAtlas2 Iteration\n * =================================\n *\n * Function used to perform a single iteration of the algorithm.\n */\n\n/**\n * Matrices properties accessors.\n */\nvar NODE_X = 0,\n    NODE_Y = 1,\n    NODE_DX = 2,\n    NODE_DY = 3,\n    NODE_OLD_DX = 4,\n    NODE_OLD_DY = 5,\n    NODE_MASS = 6,\n    NODE_CONVERGENCE = 7,\n    NODE_SIZE = 8,\n    NODE_FIXED = 9;\n\nvar EDGE_SOURCE = 0,\n    EDGE_TARGET = 1,\n    EDGE_WEIGHT = 2;\n\nvar REGION_NODE = 0,\n    REGION_CENTER_X = 1,\n    REGION_CENTER_Y = 2,\n    REGION_SIZE = 3,\n    REGION_NEXT_SIBLING = 4,\n    REGION_FIRST_CHILD = 5,\n    REGION_MASS = 6,\n    REGION_MASS_CENTER_X = 7,\n    REGION_MASS_CENTER_Y = 8;\n\nvar SUBDIVISION_ATTEMPTS = 3;\n\n/**\n * Constants.\n */\nvar PPN = 10,\n    PPE = 3,\n    PPR = 9;\n\nvar MAX_FORCE = 10;\n\n/**\n * Function used to perform a single interation of the algorithm.\n *\n * @param  {object}       options    - Layout options.\n * @param  {Float32Array} NodeMatrix - Node data.\n * @param  {Float32Array} EdgeMatrix - Edge data.\n * @return {object}                  - Some metadata.\n */\nmodule.exports = function iterate(options, NodeMatrix, EdgeMatrix) {\n\n  // Initializing variables\n  var l, r, n, n1, n2, rn, e, w, g, s;\n\n  var order = NodeMatrix.length,\n      size = EdgeMatrix.length;\n\n  var adjustSizes = options.adjustSizes;\n\n  var thetaSquared = options.barnesHutTheta * options.barnesHutTheta;\n\n  var outboundAttCompensation,\n      coefficient,\n      xDist,\n      yDist,\n      ewc,\n      distance,\n      factor;\n\n  var RegionMatrix = [];\n\n  // 1) Initializing layout data\n  //-----------------------------\n\n  // Resetting positions & computing max values\n  for (n = 0; n < order; n += PPN) {\n    NodeMatrix[n + NODE_OLD_DX] = NodeMatrix[n + NODE_DX];\n    NodeMatrix[n + NODE_OLD_DY] = NodeMatrix[n + NODE_DY];\n    NodeMatrix[n + NODE_DX] = 0;\n    NodeMatrix[n + NODE_DY] = 0;\n  }\n\n  // If outbound attraction distribution, compensate\n  if (options.outboundAttractionDistribution) {\n    outboundAttCompensation = 0;\n    for (n = 0; n < order; n += PPN) {\n      outboundAttCompensation += NodeMatrix[n + NODE_MASS];\n    }\n\n    outboundAttCompensation /= (order / PPN);\n  }\n\n\n  // 1.bis) Barnes-Hut computation\n  //------------------------------\n\n  if (options.barnesHutOptimize) {\n\n    // Setting up\n    var minX = Infinity,\n        maxX = -Infinity,\n        minY = Infinity,\n        maxY = -Infinity,\n        q, q2, subdivisionAttempts;\n\n    // Computing min and max values\n    for (n = 0; n < order; n += PPN) {\n      minX = Math.min(minX, NodeMatrix[n + NODE_X]);\n      maxX = Math.max(maxX, NodeMatrix[n + NODE_X]);\n      minY = Math.min(minY, NodeMatrix[n + NODE_Y]);\n      maxY = Math.max(maxY, NodeMatrix[n + NODE_Y]);\n    }\n\n    // squarify bounds, it's a quadtree\n    var dx = maxX - minX, dy = maxY - minY;\n    if (dx > dy) {\n      minY -= (dx - dy) / 2;\n      maxY = minY + dx;\n    }\n    else {\n      minX -= (dy - dx) / 2;\n      maxX = minX + dy;\n    }\n\n    // Build the Barnes Hut root region\n    RegionMatrix[0 + REGION_NODE] = -1;\n    RegionMatrix[0 + REGION_CENTER_X] = (minX + maxX) / 2;\n    RegionMatrix[0 + REGION_CENTER_Y] = (minY + maxY) / 2;\n    RegionMatrix[0 + REGION_SIZE] = Math.max(maxX - minX, maxY - minY);\n    RegionMatrix[0 + REGION_NEXT_SIBLING] = -1;\n    RegionMatrix[0 + REGION_FIRST_CHILD] = -1;\n    RegionMatrix[0 + REGION_MASS] = 0;\n    RegionMatrix[0 + REGION_MASS_CENTER_X] = 0;\n    RegionMatrix[0 + REGION_MASS_CENTER_Y] = 0;\n\n    // Add each node in the tree\n    l = 1;\n    for (n = 0; n < order; n += PPN) {\n\n      // Current region, starting with root\n      r = 0;\n      subdivisionAttempts = SUBDIVISION_ATTEMPTS;\n\n      while (true) {\n        // Are there sub-regions?\n\n        // We look at first child index\n        if (RegionMatrix[r + REGION_FIRST_CHILD] >= 0) {\n\n          // There are sub-regions\n\n          // We just iterate to find a \"leaf\" of the tree\n          // that is an empty region or a region with a single node\n          // (see next case)\n\n          // Find the quadrant of n\n          if (NodeMatrix[n + NODE_X] < RegionMatrix[r + REGION_CENTER_X]) {\n\n            if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n\n              // Top Left quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD];\n            }\n            else {\n\n              // Bottom Left quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;\n            }\n          }\n          else {\n            if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n\n              // Top Right quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;\n            }\n            else {\n\n              // Bottom Right quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;\n            }\n          }\n\n          // Update center of mass and mass (we only do it for non-leave regions)\n          RegionMatrix[r + REGION_MASS_CENTER_X] =\n            (RegionMatrix[r + REGION_MASS_CENTER_X] * RegionMatrix[r + REGION_MASS] +\n             NodeMatrix[n + NODE_X] * NodeMatrix[n + NODE_MASS]) /\n            (RegionMatrix[r + REGION_MASS] + NodeMatrix[n + NODE_MASS]);\n\n          RegionMatrix[r + REGION_MASS_CENTER_Y] =\n            (RegionMatrix[r + REGION_MASS_CENTER_Y] * RegionMatrix[r + REGION_MASS] +\n             NodeMatrix[n + NODE_Y] * NodeMatrix[n + NODE_MASS]) /\n            (RegionMatrix[r + REGION_MASS] + NodeMatrix[n + NODE_MASS]);\n\n          RegionMatrix[r + REGION_MASS] += NodeMatrix[n + NODE_MASS];\n\n          // Iterate on the right quadrant\n          r = q;\n          continue;\n        }\n        else {\n\n          // There are no sub-regions: we are in a \"leaf\"\n\n          // Is there a node in this leave?\n          if (RegionMatrix[r + REGION_NODE] < 0) {\n\n            // There is no node in region:\n            // we record node n and go on\n            RegionMatrix[r + REGION_NODE] = n;\n            break;\n          }\n          else {\n\n            // There is a node in this region\n\n            // We will need to create sub-regions, stick the two\n            // nodes (the old one r[0] and the new one n) in two\n            // subregions. If they fall in the same quadrant,\n            // we will iterate.\n\n            // Create sub-regions\n            RegionMatrix[r + REGION_FIRST_CHILD] = l * PPR;\n            w = RegionMatrix[r + REGION_SIZE] / 2; // new size (half)\n\n            // NOTE: we use screen coordinates\n            // from Top Left to Bottom Right\n\n            // Top Left sub-region\n            g = RegionMatrix[r + REGION_FIRST_CHILD];\n\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] = RegionMatrix[r + REGION_CENTER_X] - w;\n            RegionMatrix[g + REGION_CENTER_Y] = RegionMatrix[r + REGION_CENTER_Y] - w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            // Bottom Left sub-region\n            g += PPR;\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] = RegionMatrix[r + REGION_CENTER_X] - w;\n            RegionMatrix[g + REGION_CENTER_Y] = RegionMatrix[r + REGION_CENTER_Y] + w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            // Top Right sub-region\n            g += PPR;\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] = RegionMatrix[r + REGION_CENTER_X] + w;\n            RegionMatrix[g + REGION_CENTER_Y] = RegionMatrix[r + REGION_CENTER_Y] - w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            // Bottom Right sub-region\n            g += PPR;\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] = RegionMatrix[r + REGION_CENTER_X] + w;\n            RegionMatrix[g + REGION_CENTER_Y] = RegionMatrix[r + REGION_CENTER_Y] + w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] = RegionMatrix[r + REGION_NEXT_SIBLING];\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            l += 4;\n\n            // Now the goal is to find two different sub-regions\n            // for the two nodes: the one previously recorded (r[0])\n            // and the one we want to add (n)\n\n            // Find the quadrant of the old node\n            if (NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_X] < RegionMatrix[r + REGION_CENTER_X]) {\n              if (NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n\n                // Top Left quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD];\n              }\n              else {\n\n                // Bottom Left quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;\n              }\n            }\n            else {\n              if (NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n\n                // Top Right quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;\n              }\n              else {\n\n                // Bottom Right quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;\n              }\n            }\n\n            // We remove r[0] from the region r, add its mass to r and record it in q\n            RegionMatrix[r + REGION_MASS] = NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_MASS];\n            RegionMatrix[r + REGION_MASS_CENTER_X] = NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_X];\n            RegionMatrix[r + REGION_MASS_CENTER_Y] = NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y];\n\n            RegionMatrix[q + REGION_NODE] = RegionMatrix[r + REGION_NODE];\n            RegionMatrix[r + REGION_NODE] = -1;\n\n            // Find the quadrant of n\n            if (NodeMatrix[n + NODE_X] < RegionMatrix[r + REGION_CENTER_X]) {\n              if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n\n                // Top Left quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD];\n              }\n              else {\n                // Bottom Left quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;\n              }\n            }\n            else {\n              if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n\n                // Top Right quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;\n              }\n              else {\n\n                // Bottom Right quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;\n              }\n            }\n\n            if (q === q2) {\n\n              // If both nodes are in the same quadrant,\n              // we have to try it again on this quadrant\n              if (subdivisionAttempts--) {\n                r = q;\n                continue; // while\n              }\n              else {\n                // we are out of precision here, and we cannot subdivide anymore\n                // but we have to break the loop anyway\n                subdivisionAttempts = SUBDIVISION_ATTEMPTS;\n                break; // while\n              }\n\n            }\n\n            // If both quadrants are different, we record n\n            // in its quadrant\n            RegionMatrix[q2 + REGION_NODE] = n;\n            break;\n          }\n        }\n      }\n    }\n  }\n\n\n  // 2) Repulsion\n  //--------------\n  // NOTES: adjustSizes = antiCollision & scalingRatio = coefficient\n\n  if (options.barnesHutOptimize) {\n    coefficient = options.scalingRatio;\n\n    // Applying repulsion through regions\n    for (n = 0; n < order; n += PPN) {\n\n      // Computing leaf quad nodes iteration\n\n      r = 0; // Starting with root region\n      while (true) {\n\n        if (RegionMatrix[r + REGION_FIRST_CHILD] >= 0) {\n\n          // The region has sub-regions\n\n          // We run the Barnes Hut test to see if we are at the right distance\n          distance = (\n            (Math.pow(NodeMatrix[n + NODE_X] - RegionMatrix[r + REGION_MASS_CENTER_X], 2)) +\n            (Math.pow(NodeMatrix[n + NODE_Y] - RegionMatrix[r + REGION_MASS_CENTER_Y], 2))\n          );\n\n          s = RegionMatrix[r + REGION_SIZE];\n\n          if ((4 * s * s) / distance < thetaSquared) {\n\n            // We treat the region as a single body, and we repulse\n\n            xDist = NodeMatrix[n + NODE_X] - RegionMatrix[r + REGION_MASS_CENTER_X];\n            yDist = NodeMatrix[n + NODE_Y] - RegionMatrix[r + REGION_MASS_CENTER_Y];\n\n            if (adjustSizes === true) {\n\n              //-- Linear Anti-collision Repulsion\n              if (distance > 0) {\n                factor = coefficient * NodeMatrix[n + NODE_MASS] *\n                  RegionMatrix[r + REGION_MASS] / distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n              else if (distance < 0) {\n                factor = -coefficient * NodeMatrix[n + NODE_MASS] *\n                  RegionMatrix[r + REGION_MASS] / Math.sqrt(distance);\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            }\n            else {\n\n              //-- Linear Repulsion\n              if (distance > 0) {\n                factor = coefficient * NodeMatrix[n + NODE_MASS] *\n                  RegionMatrix[r + REGION_MASS] / distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            }\n\n            // When this is done, we iterate. We have to look at the next sibling.\n            r = RegionMatrix[r + REGION_NEXT_SIBLING];\n            if (r < 0)\n              break; // No next sibling: we have finished the tree\n\n            continue;\n          }\n          else {\n\n            // The region is too close and we have to look at sub-regions\n            r = RegionMatrix[r + REGION_FIRST_CHILD];\n            continue;\n          }\n\n        }\n        else {\n\n          // The region has no sub-region\n          // If there is a node r[0] and it is not n, then repulse\n          rn = RegionMatrix[r + REGION_NODE];\n\n          if (rn >= 0 && rn !== n) {\n            xDist = NodeMatrix[n + NODE_X] - NodeMatrix[rn + NODE_X];\n            yDist = NodeMatrix[n + NODE_Y] - NodeMatrix[rn + NODE_Y];\n\n            distance = xDist * xDist + yDist * yDist;\n\n            if (adjustSizes === true) {\n\n              //-- Linear Anti-collision Repulsion\n              if (distance > 0) {\n                factor = coefficient * NodeMatrix[n + NODE_MASS] *\n                  NodeMatrix[rn + NODE_MASS] / distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n              else if (distance < 0) {\n                factor = -coefficient * NodeMatrix[n + NODE_MASS] *\n                  NodeMatrix[rn + NODE_MASS] / Math.sqrt(distance);\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            }\n            else {\n\n              //-- Linear Repulsion\n              if (distance > 0) {\n                factor = coefficient * NodeMatrix[n + NODE_MASS] *\n                  NodeMatrix[rn + NODE_MASS] / distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            }\n\n          }\n\n          // When this is done, we iterate. We have to look at the next sibling.\n          r = RegionMatrix[r + REGION_NEXT_SIBLING];\n\n          if (r < 0)\n            break; // No next sibling: we have finished the tree\n\n          continue;\n        }\n      }\n    }\n  }\n  else {\n    coefficient = options.scalingRatio;\n\n    // Square iteration\n    for (n1 = 0; n1 < order; n1 += PPN) {\n      for (n2 = 0; n2 < n1; n2 += PPN) {\n\n        // Common to both methods\n        xDist = NodeMatrix[n1 + NODE_X] - NodeMatrix[n2 + NODE_X];\n        yDist = NodeMatrix[n1 + NODE_Y] - NodeMatrix[n2 + NODE_Y];\n\n        if (adjustSizes === true) {\n\n          //-- Anticollision Linear Repulsion\n          distance = Math.sqrt(xDist * xDist + yDist * yDist) -\n            NodeMatrix[n1 + NODE_SIZE] -\n            NodeMatrix[n2 + NODE_SIZE];\n\n          if (distance > 0) {\n            factor = coefficient *\n              NodeMatrix[n1 + NODE_MASS] *\n              NodeMatrix[n2 + NODE_MASS] /\n              distance / distance;\n\n            // Updating nodes' dx and dy\n            NodeMatrix[n1 + NODE_DX] += xDist * factor;\n            NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n            NodeMatrix[n2 + NODE_DX] += xDist * factor;\n            NodeMatrix[n2 + NODE_DY] += yDist * factor;\n          }\n          else if (distance < 0) {\n            factor = 100 * coefficient *\n              NodeMatrix[n1 + NODE_MASS] *\n              NodeMatrix[n2 + NODE_MASS];\n\n            // Updating nodes' dx and dy\n            NodeMatrix[n1 + NODE_DX] += xDist * factor;\n            NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n            NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n            NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n          }\n        }\n        else {\n\n          //-- Linear Repulsion\n          distance = Math.sqrt(xDist * xDist + yDist * yDist);\n\n          if (distance > 0) {\n            factor = coefficient *\n              NodeMatrix[n1 + NODE_MASS] *\n              NodeMatrix[n2 + NODE_MASS] /\n              distance / distance;\n\n            // Updating nodes' dx and dy\n            NodeMatrix[n1 + NODE_DX] += xDist * factor;\n            NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n            NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n            NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n          }\n        }\n      }\n    }\n  }\n\n\n  // 3) Gravity\n  //------------\n  g = options.gravity / options.scalingRatio;\n  coefficient = options.scalingRatio;\n  for (n = 0; n < order; n += PPN) {\n    factor = 0;\n\n    // Common to both methods\n    xDist = NodeMatrix[n + NODE_X];\n    yDist = NodeMatrix[n + NODE_Y];\n    distance = Math.sqrt(\n      Math.pow(xDist, 2) + Math.pow(yDist, 2)\n    );\n\n    if (options.strongGravityMode) {\n\n      //-- Strong gravity\n      if (distance > 0)\n        factor = coefficient * NodeMatrix[n + NODE_MASS] * g;\n    }\n    else {\n\n      //-- Linear Anti-collision Repulsion n\n      if (distance > 0)\n        factor = coefficient * NodeMatrix[n + NODE_MASS] * g / distance;\n    }\n\n    // Updating node's dx and dy\n    NodeMatrix[n + NODE_DX] -= xDist * factor;\n    NodeMatrix[n + NODE_DY] -= yDist * factor;\n  }\n\n  // 4) Attraction\n  //---------------\n  coefficient = 1 *\n    (options.outboundAttractionDistribution ?\n      outboundAttCompensation :\n      1);\n\n  // TODO: simplify distance\n  // TODO: coefficient is always used as -c --> optimize?\n  for (e = 0; e < size; e += PPE) {\n    n1 = EdgeMatrix[e + EDGE_SOURCE];\n    n2 = EdgeMatrix[e + EDGE_TARGET];\n    w = EdgeMatrix[e + EDGE_WEIGHT];\n\n    // Edge weight influence\n    ewc = Math.pow(w, options.edgeWeightInfluence);\n\n    // Common measures\n    xDist = NodeMatrix[n1 + NODE_X] - NodeMatrix[n2 + NODE_X];\n    yDist = NodeMatrix[n1 + NODE_Y] - NodeMatrix[n2 + NODE_Y];\n\n    // Applying attraction to nodes\n    if (adjustSizes === true) {\n\n      distance = Math.sqrt(\n        (Math.pow(xDist, 2) + Math.pow(yDist, 2)) -\n        NodeMatrix[n1 + NODE_SIZE] -\n        NodeMatrix[n2 + NODE_SIZE]\n      );\n\n      if (options.linLogMode) {\n        if (options.outboundAttractionDistribution) {\n\n          //-- LinLog Degree Distributed Anti-collision Attraction\n          if (distance > 0) {\n            factor = -coefficient * ewc * Math.log(1 + distance) /\n            distance /\n            NodeMatrix[n1 + NODE_MASS];\n          }\n        }\n        else {\n\n          //-- LinLog Anti-collision Attraction\n          if (distance > 0) {\n            factor = -coefficient * ewc * Math.log(1 + distance) / distance;\n          }\n        }\n      }\n      else {\n        if (options.outboundAttractionDistribution) {\n\n          //-- Linear Degree Distributed Anti-collision Attraction\n          if (distance > 0) {\n            factor = -coefficient * ewc / NodeMatrix[n1 + NODE_MASS];\n          }\n        }\n        else {\n\n          //-- Linear Anti-collision Attraction\n          if (distance > 0) {\n            factor = -coefficient * ewc;\n          }\n        }\n      }\n    }\n    else {\n\n      distance = Math.sqrt(\n        Math.pow(xDist, 2) + Math.pow(yDist, 2)\n      );\n\n      if (options.linLogMode) {\n        if (options.outboundAttractionDistribution) {\n\n          //-- LinLog Degree Distributed Attraction\n          if (distance > 0) {\n            factor = -coefficient * ewc * Math.log(1 + distance) /\n              distance /\n              NodeMatrix[n1 + NODE_MASS];\n          }\n        }\n        else {\n\n          //-- LinLog Attraction\n          if (distance > 0)\n            factor = -coefficient * ewc * Math.log(1 + distance) / distance;\n        }\n      }\n      else {\n        if (options.outboundAttractionDistribution) {\n\n          //-- Linear Attraction Mass Distributed\n          // NOTE: Distance is set to 1 to override next condition\n          distance = 1;\n          factor = -coefficient * ewc / NodeMatrix[n1 + NODE_MASS];\n        }\n        else {\n\n          //-- Linear Attraction\n          // NOTE: Distance is set to 1 to override next condition\n          distance = 1;\n          factor = -coefficient * ewc;\n        }\n      }\n    }\n\n    // Updating nodes' dx and dy\n    // TODO: if condition or factor = 1?\n    if (distance > 0) {\n\n      // Updating nodes' dx and dy\n      NodeMatrix[n1 + NODE_DX] += xDist * factor;\n      NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n      NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n      NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n    }\n  }\n\n\n  // 5) Apply Forces\n  //-----------------\n  var force,\n      swinging,\n      traction,\n      nodespeed,\n      newX,\n      newY;\n\n  // MATH: sqrt and square distances\n  if (adjustSizes === true) {\n\n    for (n = 0; n < order; n += PPN) {\n      if (NodeMatrix[n + NODE_FIXED] !== 1) {\n        force = Math.sqrt(\n          Math.pow(NodeMatrix[n + NODE_DX], 2) +\n          Math.pow(NodeMatrix[n + NODE_DY], 2)\n        );\n\n        if (force > MAX_FORCE) {\n          NodeMatrix[n + NODE_DX] =\n            NodeMatrix[n + NODE_DX] * MAX_FORCE / force;\n          NodeMatrix[n + NODE_DY] =\n            NodeMatrix[n + NODE_DY] * MAX_FORCE / force;\n        }\n\n        swinging = NodeMatrix[n + NODE_MASS] *\n          Math.sqrt(\n            (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) *\n            (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) +\n            (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY]) *\n            (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY])\n          );\n\n        traction = Math.sqrt(\n          (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) *\n          (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) +\n          (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY]) *\n          (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY])\n        ) / 2;\n\n        nodespeed =\n          0.1 * Math.log(1 + traction) / (1 + Math.sqrt(swinging));\n\n        // Updating node's positon\n        newX = NodeMatrix[n + NODE_X] + NodeMatrix[n + NODE_DX] *\n          (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_X] = newX;\n\n        newY = NodeMatrix[n + NODE_Y] + NodeMatrix[n + NODE_DY] *\n          (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_Y] = newY;\n      }\n    }\n  }\n  else {\n\n    for (n = 0; n < order; n += PPN) {\n      if (NodeMatrix[n + NODE_FIXED] !== 1) {\n\n        swinging = NodeMatrix[n + NODE_MASS] *\n          Math.sqrt(\n            (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) *\n            (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) +\n            (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY]) *\n            (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY])\n          );\n\n        traction = Math.sqrt(\n          (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) *\n          (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) +\n          (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY]) *\n          (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY])\n        ) / 2;\n\n        nodespeed = NodeMatrix[n + NODE_CONVERGENCE] *\n          Math.log(1 + traction) / (1 + Math.sqrt(swinging));\n\n        // Updating node convergence\n        NodeMatrix[n + NODE_CONVERGENCE] =\n          Math.min(1, Math.sqrt(\n            nodespeed *\n            (Math.pow(NodeMatrix[n + NODE_DX], 2) +\n             Math.pow(NodeMatrix[n + NODE_DY], 2)) /\n            (1 + Math.sqrt(swinging))\n          ));\n\n        // Updating node's positon\n        newX = NodeMatrix[n + NODE_X] + NodeMatrix[n + NODE_DX] *\n          (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_X] = newX;\n\n        newY = NodeMatrix[n + NODE_Y] + NodeMatrix[n + NODE_DY] *\n          (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_Y] = newY;\n      }\n    }\n  }\n\n  // We return the information about the layout (no need to return the matrices)\n  return {};\n};\n", "/**\n * Graphology ForceAtlas2 Helpers\n * ===============================\n *\n * Miscellaneous helper functions.\n */\n\n/**\n * Constants.\n */\nvar PPN = 10,\n    PPE = 3;\n\n/**\n * Very simple Object.assign-like function.\n *\n * @param  {object} target       - First object.\n * @param  {object} [...objects] - Objects to merge.\n * @return {object}\n */\nexports.assign = function(target) {\n  target = target || {};\n\n  var objects = Array.prototype.slice.call(arguments).slice(1),\n      i,\n      k,\n      l;\n\n  for (i = 0, l = objects.length; i < l; i++) {\n    if (!objects[i])\n      continue;\n\n    for (k in objects[i])\n      target[k] = objects[i][k];\n  }\n\n  return target;\n};\n\n/**\n * Function used to validate the given settings.\n *\n * @param  {object}      settings - Settings to validate.\n * @return {object|null}\n */\nexports.validateSettings = function(settings) {\n\n  if ('linLogMode' in settings &&\n      typeof settings.linLogMode !== 'boolean')\n    return {message: 'the `linLogMode` setting should be a boolean.'};\n\n  if ('outboundAttractionDistribution' in settings &&\n      typeof settings.outboundAttractionDistribution !== 'boolean')\n    return {message: 'the `outboundAttractionDistribution` setting should be a boolean.'};\n\n  if ('adjustSizes' in settings &&\n      typeof settings.adjustSizes !== 'boolean')\n    return {message: 'the `adjustSizes` setting should be a boolean.'};\n\n  if ('edgeWeightInfluence' in settings &&\n      typeof settings.edgeWeightInfluence !== 'number' &&\n      settings.edgeWeightInfluence < 0)\n    return {message: 'the `edgeWeightInfluence` setting should be a number >= 0.'};\n\n  if ('scalingRatio' in settings &&\n      typeof settings.scalingRatio !== 'number' &&\n      settings.scalingRatio < 0)\n    return {message: 'the `scalingRatio` setting should be a number >= 0.'};\n\n  if ('strongGravityMode' in settings &&\n      typeof settings.strongGravityMode !== 'boolean')\n    return {message: 'the `strongGravityMode` setting should be a boolean.'};\n\n  if ('gravity' in settings &&\n      typeof settings.gravity !== 'number' &&\n      settings.gravity < 0)\n    return {message: 'the `gravity` setting should be a number >= 0.'};\n\n  if ('slowDown' in settings &&\n      typeof settings.slowDown !== 'number' &&\n      settings.slowDown < 0)\n    return {message: 'the `slowDown` setting should be a number >= 0.'};\n\n  if ('barnesHutOptimize' in settings &&\n      typeof settings.barnesHutOptimize !== 'boolean')\n    return {message: 'the `barnesHutOptimize` setting should be a boolean.'};\n\n  if ('barnesHutTheta' in settings &&\n      typeof settings.barnesHutTheta !== 'number' &&\n      settings.barnesHutTheta < 0)\n    return {message: 'the `barnesHutTheta` setting should be a number >= 0.'};\n\n  return null;\n};\n\n/**\n * Function generating a flat matrix for both nodes & edges of the given graph.\n *\n * @param  {Graph}  graph - Target graph.\n * @return {object}       - Both matrices.\n */\nexports.graphToByteArrays = function(graph) {\n  var order = graph.order,\n      size = graph.size,\n      index = {},\n      j;\n\n  var NodeMatrix = new Float32Array(order * PPN),\n      EdgeMatrix = new Float32Array(size * PPE);\n\n  // Iterate through nodes\n  j = 0;\n  graph.forEachNode(function(node, attr) {\n\n    // Node index\n    index[node] = j;\n\n    // Populating byte array\n    NodeMatrix[j] = attr.x;\n    NodeMatrix[j + 1] = attr.y;\n    NodeMatrix[j + 2] = 0;\n    NodeMatrix[j + 3] = 0;\n    NodeMatrix[j + 4] = 0;\n    NodeMatrix[j + 5] = 0;\n    NodeMatrix[j + 6] = 1 + graph.degree(node);\n    NodeMatrix[j + 7] = 1;\n    NodeMatrix[j + 8] = attr.size || 1;\n    NodeMatrix[j + 9] = attr.fixed ? 1 : 0;\n    j += PPN;\n  });\n\n  // Iterate through edges\n  j = 0;\n  graph.forEachEdge(function(edge, attr, source, target) {\n\n    // Populating byte array\n    EdgeMatrix[j] = index[source];\n    EdgeMatrix[j + 1] = index[target];\n    EdgeMatrix[j + 2] = attr.weight || 0;\n    j += PPE;\n  });\n\n  return {\n    nodes: NodeMatrix,\n    edges: EdgeMatrix\n  };\n};\n\n/**\n * Function applying the layout back to the graph.\n *\n * @param {Graph}        graph      - Target graph.\n * @param {Float32Array} NodeMatrix - Node matrix.\n */\nexports.assignLayoutChanges = function(graph, NodeMatrix) {\n  var i = 0;\n\n  graph.updateEachNodeAttributes(function(node, attr) {\n    attr.x = NodeMatrix[i];\n    attr.y = NodeMatrix[i + 1];\n\n    i += PPN;\n\n    return attr;\n  }, {attributes: ['x', 'y']});\n};\n\n/**\n * Function collecting the layout positions.\n *\n * @param  {Graph}        graph      - Target graph.\n * @param  {Float32Array} NodeMatrix - Node matrix.\n * @return {object}                  - Map to node positions.\n */\nexports.collectLayoutChanges = function(graph, NodeMatrix) {\n  var nodes = graph.nodes(),\n      positions = {};\n\n  for (var i = 0, j = 0, l = NodeMatrix.length; i < l; i += PPN) {\n    positions[nodes[j]] = {\n      x: NodeMatrix[i],\n      y: NodeMatrix[i + 1]\n    };\n\n    j++;\n  }\n\n  return positions;\n};\n\n/**\n * Function returning a web worker from the given function.\n *\n * @param  {function}  fn - Function for the worker.\n * @return {DOMString}\n */\nexports.createWorker = function createWorker(fn) {\n  var xURL = window.URL || window.webkitURL;\n  var code = fn.toString();\n  var objectUrl = xURL.createObjectURL(new Blob(['(' + code + ').call(this);'], {type: 'text/javascript'}));\n  var worker = new Worker(objectUrl);\n  xURL.revokeObjectURL(objectUrl);\n\n  return worker;\n};\n", "/**\n * Graphology ForceAtlas2 Layout Default Settings\n * ===============================================\n */\nmodule.exports = {\n  linLogMode: false,\n  outboundAttractionDistribution: false,\n  adjustSizes: false,\n  edgeWeightInfluence: 0,\n  scalingRatio: 1,\n  strongGravityMode: false,\n  gravity: 1,\n  slowDown: 1,\n  barnesHutOptimize: false,\n  barnesHutTheta: 0.5\n};\n", "/**\n * Graphology ForceAtlas2 Layout\n * ==============================\n *\n * Library endpoint.\n */\nvar isGraph = require('graphology-utils/is-graph'),\n    iterate = require('./iterate.js'),\n    helpers = require('./helpers.js');\n\nvar DEFAULT_SETTINGS = require('./defaults.js');\n\n/**\n * Asbtract function used to run a certain number of iterations.\n *\n * @param  {boolean}       assign       - Whether to assign positions.\n * @param  {Graph}         graph        - Target graph.\n * @param  {object|number} params       - If number, params.iterations, else:\n * @param  {number}          iterations - Number of iterations.\n * @param  {object}          [settings] - Settings.\n * @return {object|undefined}\n */\nfunction abstractSynchronousLayout(assign, graph, params) {\n  if (!isGraph(graph))\n    throw new Error('graphology-layout-forceatlas2: the given graph is not a valid graphology instance.');\n\n  if (typeof params === 'number')\n    params = {iterations: params};\n\n  var iterations = params.iterations;\n\n  if (typeof iterations !== 'number')\n    throw new Error('graphology-layout-forceatlas2: invalid number of iterations.');\n\n  if (iterations <= 0)\n    throw new Error('graphology-layout-forceatlas2: you should provide a positive number of iterations.');\n\n  // Validating settings\n  var settings = helpers.assign({}, DEFAULT_SETTINGS, params.settings),\n      validationError = helpers.validateSettings(settings);\n\n  if (validationError)\n    throw new Error('graphology-layout-forceatlas2: ' + validationError.message);\n\n  // Building matrices\n  var matrices = helpers.graphToByteArrays(graph),\n      i;\n\n  // Iterating\n  for (i = 0; i < iterations; i++)\n    iterate(settings, matrices.nodes, matrices.edges);\n\n  // Applying\n  if (assign) {\n    helpers.assignLayoutChanges(graph, matrices.nodes);\n    return;\n  }\n\n  return helpers.collectLayoutChanges(graph, matrices.nodes);\n}\n\n/**\n * Function returning sane layout settings for the given graph.\n *\n * @param  {Graph|number} graph - Target graph or graph order.\n * @return {object}\n */\nfunction inferSettings(graph) {\n  var order = typeof graph === 'number' ? graph : graph.order;\n\n  return {\n    barnesHutOptimize: order > 2000,\n    strongGravityMode: true,\n    gravity: 0.05,\n    scalingRatio: 10,\n    slowDown: 1 + Math.log(order)\n  };\n}\n\n/**\n * Exporting.\n */\nvar synchronousLayout = abstractSynchronousLayout.bind(null, false);\nsynchronousLayout.assign = abstractSynchronousLayout.bind(null, true);\nsynchronousLayout.inferSettings = inferSettings;\n\nmodule.exports = synchronousLayout;\n"],
  "mappings": "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",
  "names": []
}
